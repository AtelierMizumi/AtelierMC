From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: JustMangoT <minetuan2@gmail.com>
Date: Fri, 10 Dec 2021 00:49:34 +0700
Subject: [PATCH] Lithium patches


diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/ArrayConstants.java b/src/main/java/me/jellysquid/mods/lithium/common/util/ArrayConstants.java
new file mode 100644
index 0000000000000000000000000000000000000000..1ed3c1fc57ad3e254d5c82ea4c90c3f0732165e2
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/ArrayConstants.java
@@ -0,0 +1,6 @@
+package me.jellysquid.mods.lithium.common.util;
+
+public class ArrayConstants {
+    public static final int[] EMPTY = new int[0];
+    public static final int[] ZERO = new int[]{0};
+}
diff --git a/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedReferenceList.java b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedReferenceList.java
new file mode 100644
index 0000000000000000000000000000000000000000..137a4ea1611fe636c213a6da6f64dd42096f618c
--- /dev/null
+++ b/src/main/java/me/jellysquid/mods/lithium/common/util/collections/HashedReferenceList.java
@@ -0,0 +1,281 @@
+package me.jellysquid.mods.lithium.common.util.collections;
+
+import it.unimi.dsi.fastutil.objects.Reference2IntOpenHashMap;
+import it.unimi.dsi.fastutil.objects.ReferenceArrayList;
+import it.unimi.dsi.fastutil.objects.ReferenceOpenHashSet;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+
+/**
+ * Wraps a {@link List} with a hash table which provides O(1) lookups for {@link Collection#contains(Object)}. The type
+ * contained by this list must use reference-equality semantics.
+ */
+@SuppressWarnings("SuspiciousMethodCalls")
+public class HashedReferenceList<T> implements List<T> {
+    private final ReferenceArrayList<T> list;
+    private final Reference2IntOpenHashMap<T> counter;
+
+    public HashedReferenceList(List<T> list) {
+        this.list = new ReferenceArrayList<>();
+        this.list.addAll(list);
+
+        this.counter = new Reference2IntOpenHashMap<>();
+        this.counter.defaultReturnValue(0);
+
+        for (T obj : this.list) {
+            this.counter.addTo(obj, 1);
+        }
+    }
+
+    @Override
+    public int size() {
+        return this.list.size();
+    }
+
+    @Override
+    public boolean isEmpty() {
+        return this.list.isEmpty();
+    }
+
+    @Override
+    public boolean contains(Object o) {
+        return this.counter.containsKey(o);
+    }
+
+    @Override
+    public Iterator<T> iterator() {
+        return this.listIterator();
+    }
+
+    @Override
+    public Object[] toArray() {
+        return this.list.toArray();
+    }
+
+    @SuppressWarnings("SuspiciousToArrayCall")
+    @Override
+    public <T1> T1[] toArray(T1 @NotNull [] a) {
+        return this.list.toArray(a);
+    }
+
+    @Override
+    public boolean add(T t) {
+        this.trackReferenceAdded(t);
+
+        return this.list.add(t);
+    }
+
+    @Override
+    public boolean remove(Object o) {
+        this.trackReferenceRemoved(o);
+
+        return this.list.remove(o);
+    }
+
+    @Override
+    public boolean containsAll(Collection<?> c) {
+        for (Object obj : c) {
+            if (!this.counter.containsKey(obj)) {
+                return false;
+            }
+        }
+
+        return true;
+    }
+
+    @Override
+    public boolean addAll(Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(c);
+    }
+
+    @Override
+    public boolean addAll(int index, Collection<? extends T> c) {
+        for (T obj : c) {
+            this.trackReferenceAdded(obj);
+        }
+
+        return this.list.addAll(index, c);
+    }
+
+    @Override
+    public boolean removeAll(@NotNull Collection<?> c) {
+        if (this.size() >= 2 && c.size() > 4 && c instanceof List) {
+            //HashReferenceList uses reference equality, so using ReferenceOpenHashSet is fine
+            c = new ReferenceOpenHashSet<>(c);
+        }
+        this.counter.keySet().removeAll(c);
+        return this.list.removeAll(c);
+    }
+
+    @Override
+    public boolean retainAll(@NotNull Collection<?> c) {
+        this.counter.keySet().retainAll(c);
+        return this.list.retainAll(c);
+    }
+
+    @Override
+    public void clear() {
+        this.counter.clear();
+        this.list.clear();
+    }
+
+    @Override
+    public T get(int index) {
+        return this.list.get(index);
+    }
+
+    @Override
+    public T set(int index, T element) {
+        T prev = this.list.set(index, element);
+
+        if (prev != element) {
+            if (prev != null) {
+                this.trackReferenceRemoved(prev);
+            }
+
+            this.trackReferenceAdded(element);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public void add(int index, T element) {
+        this.trackReferenceAdded(element);
+
+        this.list.add(index, element);
+    }
+
+    @Override
+    public T remove(int index) {
+        T prev = this.list.remove(index);
+
+        if (prev != null) {
+            this.trackReferenceRemoved(prev);
+        }
+
+        return prev;
+    }
+
+    @Override
+    public int indexOf(Object o) {
+        return this.list.indexOf(o);
+    }
+
+    @Override
+    public int lastIndexOf(Object o) {
+        return this.list.lastIndexOf(o);
+    }
+
+    @Override
+    public ListIterator<T> listIterator() {
+        return this.listIterator(0);
+    }
+
+    @Override
+    public ListIterator<T> listIterator(int index) {
+        return new ListIterator<>() {
+            private final ListIterator<T> inner = HashedReferenceList.this.list.listIterator(index);
+
+            @Override
+            public boolean hasNext() {
+                return this.inner.hasNext();
+            }
+
+            @Override
+            public T next() {
+                return this.inner.next();
+            }
+
+            @Override
+            public boolean hasPrevious() {
+                return this.inner.hasPrevious();
+            }
+
+            @Override
+            public T previous() {
+                return this.inner.previous();
+            }
+
+            @Override
+            public int nextIndex() {
+                return this.inner.nextIndex();
+            }
+
+            @Override
+            public int previousIndex() {
+                return this.inner.previousIndex();
+            }
+
+            @Override
+            public void remove() {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedReferenceList.this.get(last);
+
+                if (prev != null) {
+                    HashedReferenceList.this.trackReferenceRemoved(prev);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void set(T t) {
+                int last = this.previousIndex();
+
+                if (last == -1) {
+                    throw new NoSuchElementException();
+                }
+
+                T prev = HashedReferenceList.this.get(last);
+
+                if (prev != t) {
+                    if (prev != null) {
+                        HashedReferenceList.this.trackReferenceRemoved(prev);
+                    }
+
+                    HashedReferenceList.this.trackReferenceAdded(t);
+                }
+
+                this.inner.remove();
+            }
+
+            @Override
+            public void add(T t) {
+                HashedReferenceList.this.trackReferenceAdded(t);
+
+                this.inner.add(t);
+            }
+        };
+    }
+
+    @Override
+    public List<T> subList(int fromIndex, int toIndex) {
+        return this.list.subList(fromIndex, toIndex);
+    }
+
+    private void trackReferenceAdded(T t) {
+        this.counter.addTo(t, 1);
+    }
+
+    @SuppressWarnings("unchecked")
+    private void trackReferenceRemoved(Object o) {
+        if (this.counter.addTo((T) o, -1) <= 1) {
+            this.counter.removeInt(o);
+        }
+    }
+
+    public static <T> HashedReferenceList<T> wrapper(List<T> list) {
+        return new HashedReferenceList<>(list);
+    }
+}
diff --git a/src/main/java/net/minecraft/core/Direction.java b/src/main/java/net/minecraft/core/Direction.java
index 6d883db5c04cbcf454952c0f361029ecbfe4f037..72c83e3439eb6dc4ac57e4be0125940fcb17a5ed 100644
--- a/src/main/java/net/minecraft/core/Direction.java
+++ b/src/main/java/net/minecraft/core/Direction.java
@@ -191,7 +191,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public Direction getOpposite() {
-        return from3DDataValue(this.oppositeIndex);
+        return VALUES[this.oppositeIndex]; // Lithium
     }
 
     public Direction getClockWise(Direction.Axis axis) {
@@ -441,7 +441,7 @@ public enum Direction implements StringRepresentable {
     }
 
     public static Direction getRandom(Random random) {
-        return Util.getRandom(VALUES, random);
+        return VALUES[random.nextInt(VALUES.length)]; // Lithium
     }
 
     public static Direction getNearest(double x, double y, double z) {
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index af9c58944b38e8aeeca5dca75c9f97e49f2895f2..273ddb0b728acf24ad2c884ef9cf40ae8d6c8a0e 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -3019,10 +3019,12 @@ public abstract class LivingEntity extends Entity {
 
     }
 
+    private static final EquipmentSlot[] SLOTS = EquipmentSlot.values(); // Lithium
+
     @Nullable
     private Map<EquipmentSlot, ItemStack> collectEquipmentChanges() {
         Map<EquipmentSlot, ItemStack> map = null;
-        EquipmentSlot[] aenumitemslot = EquipmentSlot.values();
+        EquipmentSlot[] aenumitemslot = SLOTS;
         int i = aenumitemslot.length;
 
         for (int j = 0; j < i; ++j) {
diff --git a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
index 2f9f15d99f8b31e9f13f7f32378b2a9e09bcb5e5..d19a3de92ea12807344bf91fc7eba36b324f6be3 100644
--- a/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
+++ b/src/main/java/net/minecraft/world/level/EntityBasedExplosionDamageCalculator.java
@@ -15,9 +15,17 @@ public class EntityBasedExplosionDamageCalculator extends ExplosionDamageCalcula
 
     @Override
     public Optional<Float> getBlockExplosionResistance(Explosion explosion, BlockGetter world, BlockPos pos, BlockState blockState, FluidState fluidState) {
-        return super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState).map((max) -> {
-            return this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, max);
-        });
+        // Lithium start
+        Optional<Float> optionalBlastResistance = super.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState);
+        if (optionalBlastResistance.isPresent()) {
+            float blastResistance = optionalBlastResistance.get();
+            float effectiveExplosionResistance = this.source.getBlockExplosionResistance(explosion, world, pos, blockState, fluidState, blastResistance);
+            if (effectiveExplosionResistance != blastResistance) {
+                return Optional.of(effectiveExplosionResistance);
+            }
+        }
+        return optionalBlastResistance;
+        // Lithium end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index 90aa1d75b5c23e5ee27ceae9f6ef90de913a6601..9605600b287a80db8cea56c330332835f092d387 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -116,8 +116,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable {
     public static final int TICKS_PER_DAY = 24000;
     public static final int MAX_ENTITY_SPAWN_Y = 20000000;
     public static final int MIN_ENTITY_SPAWN_Y = -20000000;
+    // Lithium start
+    /*
     protected final List<TickingBlockEntity> blockEntityTickers = Lists.newArrayList(); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
     private final List<TickingBlockEntity> pendingBlockEntityTickers = Lists.newArrayList();
+    */
+    public final List<TickingBlockEntity> blockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedReferenceList.wrapper(Lists.newArrayList()); public final int getTotalTileEntityTickers() { return this.blockEntityTickers.size(); } // Paper
+    private final List<TickingBlockEntity> pendingBlockEntityTickers = me.jellysquid.mods.lithium.common.util.collections.HashedReferenceList.wrapper(Lists.newArrayList());
+    // Lithium end
     private boolean tickingBlockEntities;
     public final Thread thread;
     private final boolean isDebug;
diff --git a/src/main/java/net/minecraft/world/level/block/ComposterBlock.java b/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
index fb8b8a9733ac50096d8406487ab1ae167ef5f7b1..0695c276099d8bdde74e1dacf4aa00b3861dee58 100644
--- a/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/ComposterBlock.java
@@ -4,6 +4,7 @@ import it.unimi.dsi.fastutil.objects.Object2FloatMap;
 import it.unimi.dsi.fastutil.objects.Object2FloatOpenHashMap;
 import java.util.Random;
 import javax.annotation.Nullable;
+import me.jellysquid.mods.lithium.common.util.ArrayConstants; // Lithium
 import net.minecraft.world.item.ItemStack;
 import net.minecraft.world.item.Items;
 import net.minecraft.world.level.BlockGetter;
@@ -373,7 +374,7 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
 
         @Override
         public int[] getSlotsForFace(Direction side) {
-            return side == Direction.DOWN ? new int[]{0} : new int[0];
+            return side == Direction.DOWN ? ArrayConstants.ZERO : ArrayConstants.EMPTY; // Lithium
         }
 
         @Override
@@ -422,7 +423,7 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
 
         @Override
         public int[] getSlotsForFace(Direction side) {
-            return side == Direction.UP ? new int[]{0} : new int[0];
+            return side == Direction.UP ? ArrayConstants.ZERO : ArrayConstants.EMPTY; // Lithium
         }
 
         @Override
@@ -459,7 +460,7 @@ public class ComposterBlock extends Block implements WorldlyContainerHolder {
 
         @Override
         public int[] getSlotsForFace(Direction side) {
-            return new int[0];
+            return ArrayConstants.EMPTY; // Lithium
         }
 
         @Override
diff --git a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
index 28256f1f0aeb7718a5866add4ec40ce0198c36b9..02d9382937e4a1af37db21a2fc6b2a41379c433e 100644
--- a/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
+++ b/src/main/java/net/minecraft/world/level/block/piston/PistonBaseBlock.java
@@ -162,8 +162,10 @@ public class PistonBaseBlock extends DirectionalBlock {
 
     }
 
+    private static final Direction[] DIRECTIONS = Direction.values(); // JettPack
+
     private boolean getNeighborSignal(Level world, BlockPos pos, Direction pistonFace) {
-        Direction[] aenumdirection = Direction.values();
+        Direction[] aenumdirection = DIRECTIONS;
         int i = aenumdirection.length;
 
         int j;
diff --git a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
index 74210dc2eef63da7360b1f833bb59b278419fb2b..35871a988c88d18749c1e5feb643946ae11a40d7 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntitySectionStorage.java
@@ -33,31 +33,25 @@ public class EntitySectionStorage<T extends EntityAccess> {
     }
 
     public void forEachAccessibleNonEmptySection(AABB box, Consumer<EntitySection<T>> action) {
-        int i = SectionPos.posToSectionCoord(box.minX - 2.0D);
-        int j = SectionPos.posToSectionCoord(box.minY - 2.0D);
-        int k = SectionPos.posToSectionCoord(box.minZ - 2.0D);
-        int l = SectionPos.posToSectionCoord(box.maxX + 2.0D);
-        int m = SectionPos.posToSectionCoord(box.maxY + 2.0D);
-        int n = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
-
-        for(int o = i; o <= l; ++o) {
-            long p = SectionPos.asLong(o, 0, 0);
-            long q = SectionPos.asLong(o, -1, -1);
-            LongIterator longIterator = this.sectionIds.subSet(p, q + 1L).iterator();
-
-            while(longIterator.hasNext()) {
-                long r = longIterator.nextLong();
-                int s = SectionPos.y(r);
-                int t = SectionPos.z(r);
-                if (s >= j && s <= m && t >= k && t <= n) {
-                    EntitySection<T> entitySection = this.sections.get(r);
-                    if (entitySection != null && !entitySection.isEmpty() && entitySection.getStatus().isAccessible()) {
-                        action.accept(entitySection);
+        // Lithium start
+        int minX = SectionPos.posToSectionCoord(box.minX - 2.0D);
+        int minY = SectionPos.posToSectionCoord(box.minY - 2.0D);
+        int minZ = SectionPos.posToSectionCoord(box.minZ - 2.0D);
+        int maxX = SectionPos.posToSectionCoord(box.maxX + 2.0D);
+        int maxY = SectionPos.posToSectionCoord(box.maxY + 2.0D);
+        int maxZ = SectionPos.posToSectionCoord(box.maxZ + 2.0D);
+
+        for (int x = minX; x <= maxX; x++) {
+            for (int z = minZ; z <= maxZ; z++) {
+                for (int y = minY; y <= maxY; y++) {
+                    EntitySection<T> section = this.getSection(SectionPos.asLong(x, y, z));
+                    if (section != null && section.getStatus().isAccessible()) {
+                        action.accept(section);
                     }
                 }
             }
         }
-
+        // Lithium end
     }
 
     public LongStream getExistingSectionPositionsInChunk(long chunkPos) {
